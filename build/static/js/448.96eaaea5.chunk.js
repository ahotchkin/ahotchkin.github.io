"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[448],{448:(e,t,o)=>{o.r(t),o.d(t,{default:()=>i});const i='---\nlayout: post\ntitle:      "Eager Loading Makes for Eager Coding"\ndate:       2019-06-17 17:59:44 -0400\npermalink:  eager_loading_makes_for_eager_coding\n---\n\n\nThe deeper I get into Rails, the more I feel like a real-life Hermione Granger. It\u2019s magic! From a command line that seemingly gives you the world (and that\u2019s not a huge exaggeration), to helper methods that make your controllers and views very easy to read, Rails is the gift that keeps on giving. It\u2019s no different when it comes to querying databases.\n\nThrough ActiveRecord you can query databases without having to write out SQL, and you\u2019ll get back Ruby objects (not just raw data). But it gets even better. Enter eager loading. Eager loading allows you to find an object of any given class, along with its associated records from other classes, using as few queries as possible. That\'s a lot of words. Let\'s look at an example. Let\u2019s say you have the following models and relationships:\n\n```\nclass Movie << ActiveRecord::Base\n  belongs_to :director\nend\n```\n\n```\nclass Director << ActiveRecord::Base\n  has_many :movies\nend\n```\n\nAnd from the database you want to find the director for the first 20 movies. That doesn\u2019t seem too bad. It would probably look something like this:\n\n```\nmovies = Movie.limit(20)\n\nmovies.each do |movie|\n  puts movie.director.name\nend\n```\n\nIn that example, 1 query is executed to get the first 20 movies. The executed SQL would look something like this:\n```\nSELECT  "movies".* FROM "movies" LIMIT ?  [["LIMIT", 20]]\n```\n\nThen we\u2019re iterating through the movies array that was returned by the first query, and querying the directors database once for each movie (the id in the below statement updates accordingly each time, depending on the director):\n```\nSELECT  "directors".* FROM "directors" WHERE "directors"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\n```\n\nSo that\u2019s 21 queries in all\u20141 query to find the movies, and 1 query for each movie in the movies array to find the director. This is referred to as the N + 1 queries problem. In this case it\u2019s only 21 queries, so the application should be able to find this information relatively quickly. But there are more than 20 movies out there. Just this year over 40 movies have already come out, and we\u2019re still less than half way through. And that\u2019s not even counting Netflix. Or Hallmark movies! You get it, there are a lot of movies. How long would it take to query a database of 10,000 movies? Or 100,000 movies? That could take DAYS. Honestly, who has the time?!\n\n<iframe src="https://giphy.com/embed/LQvEYZn2g6KQ5NWPdz" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/patriotact-hasan-minhaj-patriot-act-digital-exclusive-LQvEYZn2g6KQ5NWPdz">via GIPHY</a></p>\n\nI said it before, but I really mean it this time: enter eager loading. A quick refresher\u2014eager loading allows you to find an object of any given class, along with its associated records from other classes, using as few queries as possible. All of this is taken care of with a very elegant solution: the `includes` finder method. To use `includes` to get the information we\u2019re looking for, you\u2019d simply write the below line of code:\n```\nmovies = Movie.includes(:director).limit(20)\n```\n\nI know what you\u2019re thinking\u2014it can\u2019t be that simple! Oh, but it is. Check it out\u2014with this line of code, 1 query will be executed to get all of the movies, and 1\u2014yep, that\u2019s right, 1\u2014additional query is executed to get the director for each movie. The SQL would look something like this:\n\n```\nSELECT  "movies".* FROM "movies" LIMIT ?  [["LIMIT", 20]]\nSELECT "directors".* FROM "directors" WHERE "directors"."id" IN (<director_ids from movies array would be listed here>)\n```\n\n<iframe src="https://giphy.com/embed/dQlgGuy4e2z8Rdk976" width="480" height="360" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/nickjonas-nick-jonas-dQlgGuy4e2z8Rdk976">via GIPHY</a></p>\n\nAfter the queries run, you\u2019re able to interact with the movies array just like you would any other array in Ruby. So you can run the same code we had above, and get all of the information you\u2019re looking for without having to query the database again:\n\n```\nmovies.each do |movie|\n  puts movie.director.name\nend\n```\n\nBy using the `includes` finder method, your application can give you the same results with way fewer queries. And you\u2019re not limited in the number of associations you can use, either. Say, for example, every movie also has a genre and you wanted to get that information as well. It\u2019s as simple as adding the genre as one of the associations:\n\n```\nMovie.includes(:director, :genre)\n```\n\nBelieve it or not, that\u2019s just scratching the surface of Active Record\u2019s finder methods. And to be honest, I\u2019m sure there are a lot more things you can even do with just the `includes` method. Maybe I\u2019ll do some more research after a quick movie break.\n\n<iframe src="https://giphy.com/embed/Bzebpz5rnyBb2" width="480" height="232" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/popcorn-emmys-2013-Bzebpz5rnyBb2">via GIPHY</a></p>\n'}}]);
//# sourceMappingURL=448.96eaaea5.chunk.js.map