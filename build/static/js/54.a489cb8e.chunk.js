"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[54],{54:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i='---\nlayout: post\ntitle:      "The (S)implicity of Ruby"\ndate:       2018-10-11 21:51:17 -0400\npermalink:  the_s_implicity_of_ruby\n---\n\n\nI\u2019ve never been one to pick up new languages very quickly. Sure, I took Spanish from 7th through 12th grade. And if I tried really hard I could probably recall a couple verb conjugation songs for you. But other than that I don\u2019t think I retained a whole lot. The only thing I really remember is from 12th grade Spanish \u2014 we would spend our Fridays eating nachos and watching George Lopez \u2014 in English. I\u2019m still taken right back there whenever I hear \u201cLow Rider\u201d. \n\nSo needless to say I was a little apprehensive when I decided to take on the challenge of learning a programming language. It is, after all, like learning to speak a foreign language. Well, luckily for me, someone knew what they were doing when they set up the Flatiron curriculum to teach Ruby as a first programming language. As someone who knew absolutely nothing about methods, classes, or object orientation a few months ago, I\u2019m grateful to have started with a language that, for all intents and purposes, feels pretty intuitive. However intuitive it may be though, it is still a programming language. And programming languages can be tricky.\n\nOne of the nuances of Ruby that tripped me up at first, but that I now find helpful, is that you don\u2019t always need to spell everything out word for word. A lot of times, what you want to say is actually implied. This is the case when it comes to return values and, in some cases, method receivers.\n\n### Return Values\n\n<iframe src="https://giphy.com/embed/C9pYsj3Lk0ET0Y9JUu" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/cbc-schittscreek-schitts-creek-C9pYsj3Lk0ET0Y9JUu">via GIPHY</a></p>\n\nFun Fact #1: In Ruby, when you want to return something, you don\u2019t actually have to use the `return` keyword. This is because Ruby uses implicit returns and will always return the last line of a method. So you\u2019d better be sure that the last line of your method is what you want returned. It\u2019s also important to note that `puts` and `print` are very different from `return`. `puts` and `print` are used to display the results of evaluated Ruby code in your console (`puts` adds a new line after executing, while `print` does not). The return value is the value of the last statement in a method. Every method in Ruby has a return value.\n\n```\ndef example_return_1\n  puts \u201cWhen executed, this method will puts this line of text.\u201d\n  \u201cBut it will return this line of text.\u201d\nend\n```\n\nIf you `puts` or `print` the last line of a method, the return value will be `nil`. When executing code in your terminal, you will see anything that your method `puts` or `print`s, but the actual return value of the method will be `nil`. If the last line of the method is a line of code to be executed, then the method will return the executed line of code.\n\n```\ndef example_return_2\n  puts \u201cWhen executed, this method will puts this line of text.\n  \u201cIt will read this line of text\u201d\n  puts \u201cAnd it will puts this line of text, then return nil.\u201d\nend\n```\n\n\n\n*A Word of Warning*\n\nIf you choose to explicitly return a line of code by using the `return` keyword, the method will stop running after that line of code. Simply put \u2014 if there is any code after the line that uses the `return` keyword, it will not run. From the little research I\u2019ve done, it seems like most Rubyists are in agreement that it is best to take advantage of Ruby\u2019s implicit return rather than using the `return` keyword.\n\n```\ndef example_return_3\n  puts \u201cWhen executed, this method will puts this line of text\u201d\n  return \u201cand it will return this line of text, then stop running.\u201d\n  puts \u201cSo it will never even get to read or execute this line of text.\u201d\n  \u201cOr this line of text. Isn\u2019t that just sad?!\u201d\nend\n```\n\n\n### Method Receivers\n\n<iframe src="https://giphy.com/embed/w2KHfIlI3V7bi" width="480" height="251" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/baby-make-austin-w2KHfIlI3V7bi">via GIPHY</a></p>\n\nFun Fact #2: Ruby has an implicit method receiver: `self`. That\u2019s right, every single method you write has a receiver, even if you don\u2019t write it out. You can tell it\u2019s implicit because you won\u2019t use dot notation. For example, you\u2019re probably very used to seeing something like this:\n\n```\nclass Person\n  attr_accessor :name, :age\nend\n```\n\nBut when you use `attr_accessor`, `self` is actually the implicit receiver. If you were to write `attr_accessor` with an explicit receiver and using dot notation, it would look like this:\n\n```\nclass Person\n  self.attr_accessor(:name, :age)\nend\n```\n\nYou\u2019re saying the exact same thing in both examples, but the first way is just a little bit cleaner. It\u2019s always good to remember (so I\'ll say it just one more time, for good measure) that every method call has a receiver, whether it\u2019s explicitly stated or not.\n\n\n*Note to Self*\n\nThe object `self` refers to is frequently changing based on the context (let\u2019s never forget that everything in Ruby is an object). `self` can be a class, or `self` can be an instance of a class. There\u2019s a chance `self` can even be something beyond one of those two things and I just haven\u2019t gotten there yet in my educational journey (which if you ask me, is kind of exciting).\n\n\nOne key takeaway, and something I didn\u2019t anticipate as I started this whole thing \u2014 the code you\u2019re not writing is just as important as the code that you are writing. Overall, I would say these nuances make Ruby easier to work with. At first I would get a little confused with what I needed to say and when (and sometimes I still do), but the more I\u2019ve used Ruby the more I\u2019ve begun to appreciate the (s)implicity of it. It\u2019s definitely a lot to keep track of though. Maybe I can come up with a catchy song to help keep it all straight.\n'}}]);
//# sourceMappingURL=54.a489cb8e.chunk.js.map