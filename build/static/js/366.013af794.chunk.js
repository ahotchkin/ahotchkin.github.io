"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[366],{366:(e,n,t)=>{t.r(n),t.d(n,{default:()=>o});const o='---\nlayout: post\ntitle:      "Sessions and Cookies and JavaScript, Oh My! - A Tutorial Series"\ndate:       2021-02-23 21:16:35 -0500\npermalink:  sessions_and_cookies_and_javascript_oh_my_-_a_tutorial_series\n---\n\n## Part 8: It\u2019s Refactoring Time!\n\nWe have made it! The final tutorial in this series. It has been quite a ride. It\u2019s hard to believe that since starting all of this we went from not having an application to having an application with fully functioning sign up and login features. And if we wanted to, we could move on right now and consider the code we have to be good enough. But that\u2019s not how we do things here. We didn\'t come this far just to come this far.\n\n<iframe src="https://giphy.com/embed/GR6E2KBt2Vm7Jjm3P1" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/xgames-x-games-real-street-realstreet-GR6E2KBt2Vm7Jjm3P1">via GIPHY</a></p>\n\nNot only do we want to write functioning code, we also want to write clean, non-repetitive code. So today we\u2019re going to focus on doing just that \u2014 cleaning up our code: making sure we don\u2019t have the same code written in multiple places, making sure all code is separated out as it should be, etc.\n\nOur backend is in pretty good shape, so today\u2019s focus will been the frontend. \n\n### DRY\n\n<iframe src="https://giphy.com/embed/yGxf8XbJHJkPUaJsGg" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/foilarmsandhog-foil-arms-and-hog-fah-sean-flanagan-yGxf8XbJHJkPUaJsGg">via GIPHY</a></p>\n\nLet\u2019s start by dealing with some repetitive code. I mentioned this in a previous tutorial \u2014 in our SignUp and Login render functions, we are essentially rendering the same form. Let\u2019s see what we can do about that.\n\nIt would seem that really we just need one component that renders a form for our users\' information. Knowing that, I\u2019m going to create a component called UserInfoForm.js. We know we\u2019re going to need React, and based on the way we have set up the application, this will be a class component, so we\u2019ll need `{ Component }` as well. Let\u2019s import those. And we may as well go ahead and define the class. Right now, I have a nice shell for my component:\n\n```\nimport React, { Component } from \'react\';\n\nclass UserInfoForm extends Component {\n\n}\n\nexport default UserInfoForm;\n```\n\nWhenever I am refactoring and trying to eliminate repeated code, I take a close look at where the code is repeated. It\u2019s important to understand where the code is exactly the same and where there are slight differences, and determine if you are able to abstract anything to handle those differences. From what I can tell, these components are very similar, from their state and functions to the rendered form. The only differences are where we say \u201cSign Up\u201d vs. \u201cLog In\u201d, and, of course, the action that is triggered when submitting the form. Because they are so similar, I\u2019m just going to copy the body of the SignUp component and paste it in the body of the UserInfoForm component. I\u2019m only taking the body of the component and leaving `mapDispatchToProps` and `connect` behind. Because the actions that we are dispatching from each component are different, we don\'t want to copy this code to UserInfoForm. Remember, we only want code that is the same.\n\nNow that we have that copied over, I\u2019m going to remove that code from the SignUp component and instead render the UserInfoForm component. Of course, I will also need to import UserInfoForm in my SignUp component. Let\u2019s head over to the browser and take a look. Make sure you\u2019re logged out, and go to your `/signup` route. Do you still see your Sign Up form? So do I! Now, we won\u2019t actually be able to use the form right now because we are calling an action in `handleOnSubmit` that isn\u2019t being imported into UserInfoForm, but don\u2019t worry, we\u2019ll go over how to handle that in a little bit. For now, let\u2019s see how we can update this component so it works with our `/login` route as well.\n\nThe first thing I notice is my big header that says \u201cSign Up\u201d. I will probably want that to say \u201cLog In\u201d on the login page, so I need to figure out how to update this. We have a couple of options. The header is actually outside of the form, so one option would be to render the header separately in each component (as we were doing previously), before rendering UserInfoForm. Another option would be to pass the header as a prop from the Sign Up and Log In components to the UserInfoForm component, and render `{this.props.header}`. Since this copy is separate from the form, I\u2019m going to leave it in the Sign Up and Log In components and remove it from the UserInfoForm component. If you want to do it the other way though, feel free!\n\nThere is one other place where we are displaying \u201cSign Up\u201d and \u201cLog In\u201d \u2014 the submit button in the form. Unfortunately, this is part of the form so it\u2019s a bit trickier to render this button in its respective components. Let\u2019s try that other option though \u2014 passing it as a prop. I\u2019m going to pass a prop from the SignUp component to the UserInfoComponent called `buttonText`, and set it to whatever I want the text in the button to be for each component. Then, in the UserInfoForm component, I\u2019ll render that prop as the button value. \n\nGreat! Now that that\u2019s settled, let\u2019s figure out how to handle our `signup` and `login` actions. Well, we\u2019ve handled the SignUp and Login differences in a couple of ways now. Do you think one of those would work for the actions? I think so! Let\u2019s pass the action as a prop to UserInfoForm. Now, in `handleOnSubmit` in UserInfoForm we can call the function we are passing as a prop. This all may be a bit confusing without any visuals. Take a look at my code so far:\n\n```\n// /src/components/SignUp.js\n\nimport React, { Component } from \'react\';\nimport { connect } from \'react-redux\';\n\n// import UserInfoForm component\nimport UserInfoForm from \'./UserInfoForm\'\nimport { signUp } from \'../actions/currentUser\';\n\nclass SignUp extends Component {\n  // remove state, handleOnChange(), and handleOnSubmit()\n\n  render() {\n    return (\n      <div>\n        <h1>Sign Up Here!</h1>\n        // render UserInfoForm component where form was previously rendered\n        // pass unique SignUp information to UserInfoForm as props\n        <UserInfoForm buttonText="Sign Up" onFormSubmit={this.props.signUp} />\n      </div>\n    )\n  }\n}\n\nexport default connect(null, { signUp })(SignUp);\n```\n\n```\n// /src/components/UserInfoForm.js\n\nimport React, { Component } from \'react\';\n\nclass UserInfoForm extends Component {\n\n  state = {\n    username: "",\n    password: ""\n  }\n\n  handleOnChange = event => {\n    this.setState({\n      [event.target.name]: event.target.value\n    })\n  }\n\n  handleOnSubmit = event => {\n    event.preventDefault();\n    // call the function being passed as the onFormSubmit prop (in the case of Sign Up, this is our signup action)\n    this.props.onFormSubmit(this.state)\n    this.setState({\n      username: "",\n      password: ""\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <form onSubmit={this.handleOnSubmit}>\n          <label htmlFor="username">Username: </label>\n          <input\n            type="text"\n            name="username"\n            id="username"\n            value={this.state.username}\n            onChange={this.handleOnChange}\n          />\n\n          <br />\n\n          <label htmlFor="password">Password: </label>\n          <input\n            type="password"\n            name="password"\n            id="password"\n            value={this.state.password}\n            onChange={this.handleOnChange}\n          />\n\n         <br />\n\n          // render the prop being passed as buttonText as the value of our Submit button\n          <input type="submit" value={this.props.buttonText} />\n        </form>\n      </div>\n    )\n  }\n\n}\n\nexport default UserInfoForm;\n```\n\nNow, see if you\u2019re able to sign up. Did it work? Nice! There\u2019s one last change you can make to the SignUp component, if you\'d like. Since we have removed state from this component, there is no reason for it to be a class component anymore, which means you can update it to a functional component. And in doing so, you\u2019ll no longer need to import `{ Component }`:\n\n```\n// /src/components/SignUp.js\n\n// remove { Component } from import\nimport React from \'react\';\nimport { connect } from \'react-redux\';\n\nimport UserInfoForm from \'./UserInfoForm\'\nimport { signUp } from \'../actions/currentUser\';\n\n// update to functional component, pass props as parameter\nconst SignUp = props => {\n\n  // remove render function and just return JSX\n  return (\n    <div>\n      <h1>Sign Up Here!</h1>\n      <UserInfoForm buttonText="Sign Up" onFormSubmit={props.signUp} />\n    </div>\n  )\n}\n\nexport default connect(null, { signUp })(SignUp);\n```\n\n\nNow we should be all set to make the same changes to the Login component, removing a bunch of repeated code in the process. I\u2019ll wait while you make your changes. If your code is anything like mine, your Login component probably looks a little something like this:\n\n```\n// /src/components/Login.js\n\nimport React from \'react\';\nimport { connect } from \'react-redux\';\n\nimport UserInfoForm from \'./UserInfoForm\'\nimport { login } from \'../actions/currentUser\';\n\nconst Login = props => {\n  return (\n    <div>\n      <h1>Log In Here!</h1>\n      <UserInfoForm buttonText="Log In" onFormSubmit={props.login} />\n    </div>\n  )\n}\n\nexport default connect(null, { login })(Login);\n```\n\nWe just got rid of a bunch of repeated code! That\u2019s great! I wonder what else we could do\u2026\n\n\n<iframe src="https://giphy.com/embed/SqQtIZBo6q2I0" width="480" height="294" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/clueless-SqQtIZBo6q2I0">via GIPHY</a></p>\n\n### Let\'s Adapt\n\nWe are handling quite a bit in our asynchronous action creators, the way they are currently written. These actions are sending fetch requests AND dispatching synchronous actions, which is a lot for an action creator to handle. To alleviate some pressure from the action creators, we can abstract our fetch requests into an Adapter class. Using adapters is a common way to add a transition layer between two interfaces, in our case our React frontend and our Rails API backend. There are several benefits of doing so, including building an application that is easier to maintain and update. And, quite frankly, who doesn\'t want that?! \n\nThe best part about this refactor is 99% of the code you need is already written, it\'s just a matter of moving it around.  We\'ll want to start by creating an adapters folder in our src folder. Then, it\'s as simple as writing an Adapter class with static methods for any fetch requests we have. Let\'s take our `signUp` function as an example. Our current `signUp` action looks like this:\n\n```\n// /src/actions.currentUser.js\n\n\u2026\n  export const signUp = credentials => {\n    const userInfo = {\n      user: credentials\n    }\n    return dispatch => {\n\t\t  // move this fetch request to an Adapter class\n      return fetch("http://localhost:3001/signup", {\n        credentials: "include",\n        method: "POST",\n        headers: {\n          "Content-type": "application/json"\n        },\n        body: JSON.stringify(userInfo)\n      })\n        .then(response => response.json())\n        .then(json => {\n          if (json.error) {\n            throw new Error(json.error)\n          } else {\n            dispatch(setCurrentUser(json.data))\n          }\n        })\n        .catch(json => console.log(json))\n    }\n  }\n\u2026\n```\n\nWe have our fetch request written already, we\'re just going to move it. Let\'s get our Adapter class set up so we can do this. In src/adapters create a file called Adapter.js, and within that file define your class:\n\n```\nclass Adapter {\n\n}\n\nexport default Adapter;\n```\n\nWe need to export the class so we can import it in src/actions/currentUser.js to have access to it. Let\'s do that now:\n\n```\n// /src/actions/currentUser.js\n\nimport Adapter from \'../adapters/Adapter\';\n```\n\nNow, in our Adapter class, let\'s define a static method for our sign up fetch request. Since we have a `signUp` action creator already, we can call this `signUpFetch` to avoid any confusion. We need to define this as a static method because it will be called on the Adapter class, not on an instance of the Adapter class. The body for the `signUpFetch` method is just going to be the fetch request you\'ve already written. It should look something like this:\n\n```\n// /src/adapters/Adapter.js\n\n\u2026\n  static signUpFetch(userInfo) {\n    return fetch("http://localhost:3001/signup", {\n      credentials: "include",\n      method: "POST",\n      headers: {\n        "Content-type": "application/json"\n      },\n      body: JSON.stringify(userInfo)\n    })\n  }\n\u2026\n```\n\nGreat! Now we just need to call this in our `signUp` action creator, replacing the fetch request that is currently there:\n\n```\n// /src/actions/currentUser.js\n\n  export const signUp = credentials => {\n    const userInfo = {\n      user: credentials\n    }\n    return dispatch => {\n      // replace fetch request with Adapter.signUpFetch()\n      return Adapter.signUpFetch(userInfo)\n        .then(response => response.json())\n        .then(json => {\n          if (json.error) {\n            throw new Error(json.error)\n          } else {\n            dispatch(setCurrentUser(json.data))\n          }\n        })\n        .catch(json => console.log(json))\n    }\n  }\n\n```\n\nIf you try to sign up with a new account, everything should be functioning as it was before. We have just abstracted some of the code, creating a class whose only responsibility is talking to our API. This is going to make your life much easier if you have any updates to your backend that will impact your fetch requests, because all fetch requests will happen from one place. You\'re all set to abstract the rest of your fetch requests into static methods in your Adapter class.\n\n### Is that it?\n\nFor now, yes, that is it! We have completed our tutorial series for JavaScript, Sessions, and Cookies (Oh My!). You should be proud of what you accomplished! Of course this series could go on for weeks and weeks still, but it is time to move on with your application. You can finally start adding other components and features, knowing that you have a complete user experience set to go. So go on, now. Get out of here.\n\n<iframe src="https://giphy.com/embed/bqYORK2hUYlb2" width="480" height="200" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/ferris-buellers-day-off-matthew-broderick-bueller-bqYORK2hUYlb2">via GIPHY</a></p>\n\n<br>\n\n##### Sources\n\n<a href="https://sendgrid.com/blog/using-the-adapter-design-pattern-with-react/">Adapter Design Pattern</a>\n<br>\n<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">Static Methods</a>\n<br>\n<a href="https://instruction.learn.co/student/video_lectures#/463">Flatiron School React App Build</a>\n\n'}}]);
//# sourceMappingURL=366.013af794.chunk.js.map