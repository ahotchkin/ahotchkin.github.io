"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[323],{323:(e,t,n)=>{n.r(t),n.d(t,{default:()=>a});const a='---\nlayout: post\ntitle:      "How Harry Potter Inspired My JavaScript Project"\ndate:       2020-03-10 15:28:28 -0400\npermalink:  how_harry_potter_inspired_my_javascript_project\n---\n\n\n\nWhen it came time to start my JavaScript Project for Flatiron School, I\u2019ll admit I was pretty lost. JavaScript still felt very confusing and foreign to me, so how was I supposed to develop an entire project with a JavaScript frontend? Up to this point, combining a project with one of my interests had proven to be pretty successful. Given my lack of confidence in JavaScript, I needed to pick an interest where my confidence was overflowing. I know what you\u2019re all thinking. "Is this it? Is this the project where Ally incorporates Harry Potter?" If you\u2019ve read the title of this post, then you\u2019ll already know the answer is a resounding yes! After careful consideration, I decided to test (and develop) my JavaScript (and Harry Potter) knowledge by creating a Harry Potter Trivia game.\n\n<iframe src="https://giphy.com/embed/l3q2VTSmfyXXaBR1m" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/harry-potter-hagrid-l3q2VTSmfyXXaBR1m">via GIPHY</a></p>\n\n<br>\n\n### Where to begin?\n\nKnowing that I needed a Rails backend, I figured that was the place to start. I felt comfortable with the Rails requirements and understood how to implement what was needed. I\u2019ve gotten in the habit of creating an outline to help me understand all of my models and relationships, and this project was no different.\n\n<img src="https://user-images.githubusercontent.com/33204849/76707964-c226be00-66c9-11ea-8d16-b32f848a6a88.jpg" width="800" height="655">\n\n\nWith all of that in place, I was able to create the necessary database tables and corresponding models. At this point you\'re probably thinking, "But Ally, why are we talking about Rails? This is your JavaScript project." And you\u2019re right, we don\u2019t need to get into the Rails details, we\u2019ve already done that. So let\u2019s move on.\n\n<br>\n\n### But where to begin with JavaScript?\n\nWhen it came to the JavaScript side of things, I truly had no idea where to start. Luckily, I was able to find an old video walkthrough of creating an app with a Rails API backend and a JavaScript frontend (hey, that\u2019s what I was doing!). As it turned out, the best place to start was to figure out just that\u2014where would my app start? Knowing that I wanted: 1. My code to be as clean and DRY as possible, and 2. Code concerning different elements to be separated into different files, I started with my index.js file. It was there where I wrote one whole line of code:\n\n```\nconst app = new App()\n```\n\nThis, in turn, points to my app.js file, which has a whopping five lines of code:\n\n```\nclass App {\n  constructor() {\n    this.user = new User(username);\n  }\n}\n```\n\nAnd this is where the app really takes off. Creating that User directs to the user.js file where a new instance of User is created:\n\n```\nconstructor(username) {\n  this.username = username;\n  this.adapter = new UsersAdapter();\n  this.userEventListeners();\n}\n```\n\nThis User instance sets a lot of wheels in motion by connecting to the UsersAdapter and calling `userEventListeners()`, making it possible to take the user input and create an instance of User in the Rails database. We\'re off to a great start! But what would happen next? Well, a user would type in a username and click submit. And we\'re off...\n\n<iframe src="https://giphy.com/embed/AV5y1BxRNEATK" width="480" height="201" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/harry-potter-cos-AV5y1BxRNEATK">via GIPHY</a></p>\n\n<br>\n\n### Client-Server Communication \u2014 POST Request\n\nTo start the game, a user has to enter a username and select their house. `userEventListeners()` adds an event listener to the submit button, so by clicking on this button `createUser()` is called on the User instance<sup>1</sup>:\n\n```\ncreateUser(event) {\n  event.preventDefault();\n\n  if (DOMElements.username.value === "") {\n    alert("Please enter a username.");\n  } else {\n    DOMElements.audio.play();\n    // take the below value and make a POST request using the adapter\n    const value = DOMElements.username.value;\n\n    this.adapter.createUser(value)\n      .then(user => {\n        this.renderUserStartPage(user);\n      });\n  };\n}\n```\n\nAs long as the user has entered a username, `this.adapter.createUser()` is called. The value that is passed in is the user input. Let\'s take a look at what is happening in the adapter:\n\n```\nclass UsersAdapter {\n\n  constructor() {\n    this.baseUrl = "http://localhost:3000/api/v1/users";\n  }\n\n  createUser(value) {\n    const user = {\n      username: value\n    };\n\n    return fetch(this.baseUrl, {\n      method: "POST",\n      headers: {\n        "Content-Type": "application/json",\n        "Accept": "application/json"\n      },\n      body: JSON.stringify({\n        user\n      })\n    })\n    // below sends a parsed JSON object back to the users component in createUser()\n    .then(response => response.json())\n  }\n}\n```\n\nThe Users Controller is rendering this information as JSON in a create method, which allows the adapter to complete the `POST` request:\n\n```\ndef create\n  @user = User.new(user_params)\n  if @user.save\n    render json: @user.to_json, status: 200\n  end\nend\n```\n\nThe fetch request in the adapter returns a `Promise`. A `Promise` is essentially a wrapper for code that might take a second to resolve. I\'m actually not going to get into that too much here since I wrote another <a href="http://allysonhotchkin.com/await_what">post</a> focusing on `Promise`s, but just know that they allow you to run synchronous code in an asynchronous language (like JavaScript). A fancy way of saying, "Hang on a second, I just gotta finish this one thing and then we can keep going."\n\nOkay, back to `createUser()` in user.js. This is where the JSON object is used when rendering the User\'s start page. Just in case you forgot or don\'t feel like scrolling up:\n\n```\ncreateUser(event) {\n  ...\n    this.adapter.createUser(value)\n      .then(user => {\n      this.renderUserStartPage(user);\n    });\n  ...\n}\n```\n\nWe now have that user\u2019s information (their username) and can display it back to them in `renderUserStartPage()`.\n\n\n<img src="https://user-images.githubusercontent.com/33204849/76708707-5c3d3500-66cf-11ea-9785-536fff4cdce2.png" width="800" height="388px">\n\n\nWhew, that was a lot. And that\'s just one example of a `POST` request. UserAnswers and UserRounds work in a similar fashion. That information is important to determine if a user has successfully completed a round, but I won\'t bore you with the details since the `POST` requests aren\u2019t much different. I\'ll bore you with other details instead.\n\nOnce a user is created, they can start the first round. This brings us to the next type of request that is made.\n\n<br>\n\n### Client-Server Communication \u2014 GET Request\n\nThe `GET` request isn\u2019t as complicated as the `POST` request, since no new information is being created. The program is simply fetching information that already exists in the database. In HPT (Harry Potter Trivia, obvi), `GET` requests are used to fetch the rounds and questions for the game. When a user clicks on the button to start the game, a new JavaScript instance of a Round is created. Similarly to a User, this binds an adapter to the instance of Round, and calls `roundBindingsAndEventListeners()` on this new instance. `roundBindingsAndEventListeners()` includes instructions for what should happen when several different buttons are clicked (and even creates some new buttons). A great example, especially since we\'re talking about `GET` requests, is calling `fetchAndLoadRound()` when the start button is clicked:\n\n```\nfetchAndLoadRound(event) {\n  event.preventDefault();\n  this.adapter.getRound()\n    .then(round => {\n      this.renderRound(round);\n    });\n}\n```\n\n`fetchAndLoadRound()` calls `getRound()` on the adapter:\n\n```\ngetRound() {\n  return fetch(this.baseUrl).then(response => response.json());\n}\n```\n\nThis is a fetch request to the Round\'s URL, which is connected to the `show` action in the Rounds Controller:\n\n```\ndef show\n  @round = Round.find(params[:id])\n  render json: RoundSerializer.new(@round).to_serialized_json, status: 200\nend\n```\n\nGoing back to `getRound()`, we pass a callback function to `.then`, which returns a response that we can then turn into JSON. This JSON object is used as an argument in `renderRound()`, which is called in `fetchAndLoadRound()`.\n\nThe individual questions belong to a round, so in `renderRound()` we loop through all of the round\'s questions and take the necessary steps to render the question information to the page. We\'ll take a look at this in a bit. But first, there\'s one last type of fetch request occurring in the game. In some instances, we aren\u2019t looking to get information from the database or even post information, we\u2019re looking to update information that already exists. Enter `PATCH` requests.\n\n<br>\n\n### Client-Server Communication \u2014 PATCH Request\n\nPart of the HPT challenge is that a user only has 3 chances to successfully complete a round before Voldemort takes control of the Wizarding World. Part of the challenge of this project was figuring out how to make that work. When it comes to the UserRounds, the first step is to create an instance in the database. When a user clicks the button to Board the Hogwarts Express for a round, an instance of UserRound is created with the current User\'s ID, the Round ID, and the number of attempts (initially set equal to 1). If a user doesn\'t answer at least 5 questions correctly, they have a chance to retry the round. Should this occur, we don\'t want to create an entirely new instance of UserRound, we want to take the UserRound that was just created and increase the number of attempts by 1. Doing so allows the program to cut off the user after 3 attempts in any given round, as well as display the number of attempts per round on the stats page. The process of creating the UserRound is pretty similar to what we\u2019ve seen already.\n\nThe start button is clicked, which triggers the Round class to begin said process:\n\n```\ncreateUserRound(event) {\n  event.preventDefault();\n  const userRound = new UserRound(this.user.id, this.id);\n  userRound.createUserRound();\n}\n```\n\nThe above triggers `createUserRound()` in the UserRound class:\n\n```\ncreateUserRound() {\n  this.adapter.createUserRound(this)\n    .then(userRound => {\n      DOMElements.tryAgain.dataset.userRoundId = userRound.id;\n      DOMElements.tryAgain.dataset.userId = userRound.user_id;\n      DOMElements.tryAgain.dataset.roundId = userRound.round_id;\n      DOMElements.tryAgain.dataset.attempts = userRound.attempts;\n    });\n}\n```\n\nWhat\'s happening here is we\'re appending UserRound data to the \u201cTry Again\u201d button so we can have access to it, if needed. If there\'s a chance we\'ll need to update the UserRound, we have to be able to access that UserRound.\n\n<img width="800" alt="Screen Shot 2020-03-10 at 2 43 23 PM" src="https://user-images.githubusercontent.com/33204849/76347817-98daec00-62dd-11ea-8b23-7ba812874ab5.png">\n\nIf a user answers at least 5 questions correctly, they click the start button for the next round and `createUserRound()` is triggered again, creating a new instance of UserRound with the new Round ID. However, if a user does not answer at least 5 questions correctly they\'ll have the option to try the round again. Clicking the \u201cTry Again\u201d button (as shown above) triggers `updateUserRound()` in the Round class. This is where we create a new JavaScript instance of a UserRound, giving it all of the same elements as the last UserRound, but increasing the attempts by 1:\n\n```\nupdateUserRound(event) {\n  event.preventDefault();\n  const userRound = new UserRound(parseInt(DOMElements.tryAgain.dataset.userId), parseInt(DOMElements.tryAgain.dataset.roundId), (parseInt(DOMElements.tryAgain.dataset.attempts) + 1));\n  userRound.updateUserRound();\n}\n```\n\nThis triggers `updateUserRound()` in the UserRound class:\n\n```\nupdateUserRound() {\n  this.adapter.updateUserRound(this, parseInt(DOMElements.tryAgain.dataset.userRoundId))\n    .then(userRound => {\n      DOMElements.tryAgain.dataset.attempts = userRound.attempts;\n    });\n}\n```\n\nThe above method makes a call to the adapter and passes in the new JavaScript instance of the UserRound (which remember, is the same as the previous instance of the UserRound, except the number of attempts has increased by 1), as well as the ID of the UserRound being updated, so a patch request can be made:\n\n```\nupdateUserRound(userRound, id) {\n  let attempts = userRound.attempts;\n\n  return fetch(this.baseUrl + `/${id}`, {\n    method: "PATCH",\n    headers: {\n      "Content-Type": "application/json",\n      "Accept": "application/json"\n    },\n    body: JSON.stringify({\n      attempts: userRound.attempts\n    })\n  })\n  .then(response => response.json())\n}\n```\n\nThis patch request sends the information to the UserRound\'s URL to update the instance of the UserRound via the UserRounds Controller:\n\n```\ndef update\n  @user_round = UserRound.find_by_id(params[:id])\n  if @user_round.update(user_round_params)\n    render json: @user_round.to_json, status: 200\n  end\nend\n```\n\nWow, I\'m wiped. And that doesn\'t even cover all of the communication that is occurring between the client and the server. But it does provide a nice overview of the range of ways in which the two are communicating, and how they are working together to transfer information back and forth.\n\nGreat, so we can get information from the client to the server and vice versa. But how do we actually display this information to the user, you ask? By all means, keep reading.\n\n<br>\n\n### The DOM\n\nManipulating the DOM and rendering content was a major part of this project since it was a Single Page Application. There were a couple of ways to make this easier, like making sure my HTML was organized and utilizing the ID property when I could. But if you can remember all the way back to the beginning of this post, when I started building the app I had separated my JavaScript classes into different files. As a result, I found that I was having to repeat the same code when trying to access DOM elements across files. Not very DRY at all. There had to be a better way! And as in most cases, it turns out there was. I created a DOMElements class that contained static getter methods for all of the DOM elements I would need to grab throughout the program. This way I only had to grab the element once, and I could call these methods in any of my other files with `domElements.methodName()`. Here are a couple examples of those static getter methods, just for you:\n\n```\nstatic get body() { return document.querySelector("body") };\nstatic get header() { return document.getElementById("header") };\nstatic get newUserForm() { return document.getElementById("new_user_form") };\n```\n\nNow that I had access to the DOM elements, I had to figure out how to manipulate them to display the information from the backend. The DOM can be really powerful, giving you the ability to add/change innerHTML, add elements, append elements, etc. After understanding that, it was just a matter of finding the DOM element I needed and setting the innerHTML equal to the appropriate attribute of the JSON object I had access to. Sure, in some instances I would need to create new elements or update the IDs of current elements, but a lot of figuring that out was just trial and error. \n\nRemember how I said that for each round it was necessary to render the round\'s questions on the page? Well, in the end, `renderQuestion()` looked like this:\n\n```\nrenderQuestion(question) {\n  // displays the quiz_container element, which is currently hidden\n  DOMElements.quiz_container.style.display = \u201ctable";\n  // creates a \u201cp\u201d element for the question\n  const q = document.createElement("p");\n\n  // sets the innerHTML of q equal to attributes of the question object\n  q.innerHTML = `${question.question_number}. ${question.content}`;\n  // attaches q to the quiz_form\n  DOMElements.quiz_form.appendChild(q);\n\n  // loops through the 4 answer choices for the question\n  for (let i = 1; i < 5; i++) {\n    // creates DOM elements that are needed to display each answer choice\n    const div = document.createElement("div");\n    const answer = document.createElement("input");\n    const answer_text = document.createElement("label");\n\n    // sets the necessary attributes of the answer so it behaves properly (i.e. can only select one answer per question)\n    answer.setAttribute("type", "radio");\n    answer.setAttribute("name", question.id);\n    answer.setAttribute("class", "form-check-input");\n    answer.setAttribute("id", "user_input");\n    answer_text.className = "form-check-label";\n\n    switch (i) {\n      case 1:\n        answer.setAttribute("value", "A");\n        answer_text.innerText = ` ${question.answer_a}`;\n        break;\n      case 2:\n        answer.setAttribute("value", "B");\n        answer_text.innerText = ` ${question.answer_b}`;\n        break;\n      case 3:\n        answer.setAttribute("value", "C");\n        answer_text.innerText = ` ${question.answer_c}`;\n        break;\n      case 4:\n        answer.setAttribute("value", "D");\n        answer_text.innerText = ` ${question.answer_d} \\n\\n\\n`;\n    };\n\n    // attaches the div to the quiz_form and the answer information to the div\n    DOMElements.quiz_form.appendChild(div);\n    div.appendChild(answer);\n    div.appendChild(answer_text);\n  };\n}\n```\n\nAll of that to display one question:\n\n<img width="575" alt="Screen Shot 2020-03-10 at 3 27 22 PM" src="https://user-images.githubusercontent.com/33204849/76351325-a1362580-62e3-11ea-9da1-c29d4f6b3cf9.png">\n\n<br>\n\n### Is that everything?\n\nOf course not! This project was a huge learning experience, delving into the JavaScript world for the first time. I\u2019ve hardly even scratched the surface, which is both crazy and exciting. I feel like I could improve this project in a myriad of ways, and could probably spend a few solid weeks (or months) doing so. That being said, I think it all seems to be working okay as is, and at this point my time is probably better spent moving on and continuing my journey. So when it comes to Harry Potter Trivia, for now I\'ll say Mischief Managed.\n\n<iframe src="https://giphy.com/embed/qLHzYjlA2FW8g" width="480" height="209" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/harry-potter-graduation-qLHzYjlA2FW8g">via GIPHY</a></p>\n\n*<sup>1</sup>Code has since been updated to use async/await instead of `then()` in all instances*\n\n\n\n'}}]);
//# sourceMappingURL=323.771da2de.chunk.js.map